/**
 * Slideshow frontend script
 *
 * @author Stefan Boonstra
 * @version 4.1.0
 */
slideshow_jquery_image_gallery_script = function()
{
	var $    = jQuery,
		self = {};

	self.registeredSlideshows = [ ];
	self.youTubeAPIReady      = false;
	self.loadYouTubeAPICalled = false;
	self.stylesheetURLChecked = false;
	self.API                  = new SlideshowAPI();

	/**
	 * Instantiates Slideshow objects on all slideshow elements that have not yet been registered of having a Slideshow
	 * instance.
	 */
	self.activateSlideshows = function()
	{
		$.each(jQuery('.slideshow_container'), function(key, slideshowElement)
		{
			var $slideshowElement = $(slideshowElement),
				ID                = $slideshowElement.data('sessionId');

			if (isNaN(parseInt(ID, 10)))
			{
				ID = $slideshowElement.attr('data-session-id');
			}

			if ($.inArray(ID, self.registeredSlideshows) < 0)
			{
				new self.Slideshow($slideshowElement);
			}

//			if (!(self.registeredSlideshows[ID] instanceof self.Slideshow))
//			{
//				self.registeredSlideshows[ID] = new self.Slideshow($slideshowElement);
//			}
		});
	};

	/**
	 *
	 */
	self.loadYouTubeAPI = function()
	{
		if (self.loadYouTubeAPICalled)
		{
			return;
		}

		self.loadYouTubeAPICalled = true;

		if ($('.slideshow_slide_video').length <= 0)
		{
			return;
		}

		var tag            = document.createElement('script'),
			firstScriptTag = document.getElementsByTagName('script')[0];

		tag.src = "//www.youtube.com/iframe_api";

		firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
	};

	/**
	 *
	 */
	self.checkStylesheetURL = function()
	{
		if (self.stylesheetURLChecked)
		{
			return;
		}

		self.stylesheetURLChecked = true;

		var ajaxStylesheets = $('[id*="slideshow-jquery-image-gallery-ajax-stylesheet_"]');

		if (ajaxStylesheets.length <= 0)
		{
			return;
		}

		$.each(ajaxStylesheets, function(ajaxStylesheetKey, ajaxStylesheet)
		{
			var $ajaxStylesheet = $(ajaxStylesheet),
				URL             = $(ajaxStylesheet).attr('href'),
				styleNameParts,
				styleName,
				URLData;

			if (URL === undefined ||
				URL === '')
			{
				return;
			}

			// Get the style name from the element's ID. Splits at the first underscore and removes WordPress' stylesheet suffix: '-css'
			styleNameParts = $ajaxStylesheet.attr('id').split('_');
			styleName      = styleNameParts.splice(1, styleNameParts.length - 1).join('_').slice(0, -4);

			URLData = URL.split('?');

			if (URLData[1] === undefined ||
				URLData[1] === '' ||
				URLData[1].toLowerCase().indexOf('style=') < 0)
			{
				URLData[1] =
					'action=slideshow_jquery_image_gallery_load_stylesheet' +
						'&style=' + styleName +
						'&ver=' + Math.round((new Date().getTime() / 1000));
			}
			else
			{
				return;
			}

			URL = URLData.join('?');

			$ajaxStylesheet.attr('href', URL);
		});
	};

	$(document).ready(function()
	{
		self.loadYouTubeAPI();
		self.checkStylesheetURL();
		self.activateSlideshows();
	});

	$(window).load(function()
	{
		self.loadYouTubeAPI();
		self.checkStylesheetURL();
		self.activateSlideshows();
	});

	return self;
}();

function onYouTubeIframeAPIReady()
{
	slideshow_jquery_image_gallery_script.youTubeAPIReady = true;
}

// @codekit-append frontend/slideshow.js
// @codekit-append frontend/slideshowAPI.js

///**
//* Simple logging function for Internet Explorer
//*
//* @param message
//*/
//function log(message)
//{
//	var $ = jQuery;
//
//	$('body').prepend('<p style="color: red;">' + message +  '</p>');
//}

// @codekit-append slideshow/slideshow.constructor.js
// @codekit-append slideshow/slideshow.base.js
// @codekit-append slideshow/slideshow.animation.js
// @codekit-append slideshow/slideshow.calculation.js
// @codekit-append slideshow/slideshow.modules.js
(function()
{
	var $    = jQuery,
		self = slideshow_jquery_image_gallery_script;

	/**
	 * Slideshow API constructor
	 *
	 * @param slideshowInstances =
	 */
	self.SlideshowAPI = function($slideshow)
	{

	}
})();(function()
{
	var $    = jQuery,
		self = slideshow_jquery_image_gallery_script;

	/**
	 * Slideshow constructor
	 *
	 * @param $slideshow (jQuery)
	 */
	self.Slideshow = function($slideshow)
	{
		// Element variables
		this.$container        = $slideshow;
		this.$content          = this.$container.find('.slideshow_content');
		this.$views            = this.$container.find('.slideshow_view');
		this.$slides           = this.$container.find('.slideshow_slide');
		this.$controlPanel     = this.$container.find('.slideshow_controlPanel');
		this.$togglePlayButton = this.$controlPanel.find('.slideshow_togglePlay');
		this.$nextButton       = this.$container.find('.slideshow_next');
		this.$previousButton   = this.$container.find('.slideshow_previous');
		this.$pagination       = this.$container.find('.slideshow_pagination');
		this.$loadingIcon      = this.$container.find('.slideshow_loading_icon');

		/** Settings */
		this.ID = this.getID();

		if (isNaN(parseInt(this.ID, 10)))
		{
			return;
		}

		this.settings = window['SlideshowPluginSettings_' + this.ID];

		// Convert 'true' and 'false' to boolean values.
		$.each(this.settings, $.proxy(function(setting, value)
		{
			if (value == 'true')
			{
				this.settings[setting] = true;
			}
			else if (value == 'false')
			{
				this.settings[setting] = false;
			}
		}, this));

		// Interchanging variables
		this.$parentElement   = this.$container.parent();
		this.viewData         = [];
		this.viewIDs          = [];
		this.navigationActive = true;
		this.currentViewID    = undefined;
		this.currentWidth     = 0;
		this.visibleViews     = [];
		this.videoPlayers     = [];
		this.PlayStates       = { PAUSED: -1, TEMPORARILY_PAUSED: 0, PLAYING: 1 }
		this.playState        = -1;

		// Timers
		this.interval          = false;
		this.pauseOnHoverTimer = false;
		this.invisibilityTimer = false;
		this.descriptionTimer  = false;

		// Randomization
		this.randomNextHistoryViewIDs     = [];
		this.randomPreviousHistoryViewIDs = [];
		this.randomAvailableViewIDs       = [];

		$.each(this.$views, $.proxy(function(viewID){ this.viewIDs.push(viewID); }, this));

		this.currentViewID = this.getNextViewID();

		this.visibleViews = [this.currentViewID];

		// Initial size calculation of slideshow, doesn't recalculate views
		this.recalculate(false);

		// Initialize $viewData array as $viewData[ view[ slide{ 'loaded': 0 } ] ]
		// Add slideshow_currentView identifier class to the visible views
		// Recalculate views
		// Hide views out of the content area
		var hasFirstSlideLoaded = true;
		$.each(this.$views, $.proxy(function(viewID, view)
		{
			var $view = $(view);

			// Hide views, except for the one that's currently showing.
			if (viewID != this.visibleViews[0])
			{
				$view.css('top', this.$container.outerHeight(true));
			}
			else
			{
				$view.addClass('slideshow_currentView');
			}

			this.viewData[viewID] = [];

			$.each($view.find('.slideshow_slide'), $.proxy(function(slideID, slide)
			{
				var $slide = $(slide);

				//this.viewData[viewID][slideID] = { 'imageDimension': '' };
				this.viewData[viewID][slideID] = { };

				// Check if the image in this slide is loaded. The loaded value van have the following values:
				// -1: Slide is no image slide, 0: Not yet loaded, 1: Successfully loaded, 2: Unsuccessfully loaded
				if ($slide.hasClass('slideshow_slide_image'))
				{
					var $image = $slide.find('img');

					if ($image.length > 0)
					{
						if ($image.get(0).complete)
						{
							this.viewData[viewID][slideID].loaded = 1;
						}
						else
						{
							if (viewID === this.currentViewID)
							{
								hasFirstSlideLoaded = false;
							}

							this.viewData[viewID][slideID].loaded = 0;

							this.onImageLoad($image, $.proxy(function(success)
							{
								if (success)
								{
									this.viewData[viewID][slideID].loaded = 1;
								}
								else
								{
									this.viewData[viewID][slideID].loaded = 2;
								}

								if (this.settings['waitUntilLoaded'] &&
									viewID === this.currentViewID &&
									this.isViewLoaded((viewID)))
								{
									this.start();
								}
							}, this));
						}
					}
					else
					{
						this.viewData[viewID][slideID].loaded = -1;
					}
				}
				else
				{
					this.viewData[viewID][slideID].loaded = -1;
				}
			}, this));
		}, this));

		// Recalculate visible views when window is loaded
		$(window).load($.proxy(function()
		{
			this.recalculateVisibleViews();
		}, this));

		// Check if intervalSpeed is greater than slideSpeed
		if (parseFloat(this.settings['intervalSpeed']) < parseFloat(this.settings['slideSpeed']) + 0.1)
		{
			this.settings['intervalSpeed'] = parseFloat(this.settings['slideSpeed']) + 0.1;
		}

		// Activate modules
		this.activateDescriptions();
		this.activateControlPanel();
		this.activateNavigationButtons();
		this.activatePagination();
		this.activatePauseOnHover();

		// Start slideshow
		if (!this.settings['waitUntilLoaded'] ||
			(this.settings['waitUntilLoaded'] && hasFirstSlideLoaded))
		{
			this.start();
		}
	};
}());(function()
{
	var $    = jQuery,
		self = slideshow_jquery_image_gallery_script;

	/**
	 * Initial start method
	 */
	self.Slideshow.prototype.start = function()
	{
		if (this.$loadingIcon.length > 0)
		{
			this.$loadingIcon.remove();
		}

		// Show content
		this.$content.show();

		this.recalculateViews();

		// Register recalculation on window resize
		if (this.settings['enableResponsiveness'])
		{
			$(window).resize($.proxy(function()
			{
				this.recalculate(true);
			}, this));
		}

		this.play();
	};

	/**
	 * Sets the slideshow's animation interval when play is true.
	 */
	self.Slideshow.prototype.play = function()
	{
		// Only start when play is true and no interval is currently running
		if (!this.settings['play'] ||
			this.interval)
		{
			return;
		}

		this.playState = this.PlayStates.PLAYING;

		this.$container.trigger('slideshowPlayStateChange', [ this.playState ]);

		// Set interval to intervalSpeed
		this.interval = setInterval(
			$.proxy(function retrieveViewAndAnimateToView(viewID, slideshowInstance)
			{
				// The slideshowInstance variable is necessary here, as 'this' will sometimes refer to 'window'
				if (slideshowInstance === undefined)
				{
					slideshowInstance = this;
				}

				if (viewID === undefined)
				{
					viewID = slideshowInstance.getNextViewID();
				}

				if (slideshowInstance.isViewLoaded(viewID))
				{
					slideshowInstance.animateTo(viewID, 1);

					slideshowInstance.play();
				}
				else
				{
					slideshowInstance.pause(this.PlayStates.TEMPORARILY_PAUSED);

					setTimeout($.proxy(function(){ retrieveViewAndAnimateToView(viewID, slideshowInstance); }, slideshowInstance), 100);
				}
			}, this),
			this.settings['intervalSpeed'] * 1000
		);
	};

	/**
	 * Stops the slideshow's animation interval. $interval is set to false.
	 *
	 * @param playState (PlayState) Optional, defaults to this.PlayState.PAUSED
	 */
	self.Slideshow.prototype.pause = function(playState)
	{
		clearInterval(this.interval);

		this.interval = false;

		if (playState !== this.PlayStates.PAUSED &&
			playState !== this.PlayStates.TEMPORARILY_PAUSED)
		{
			playState = this.PlayStates.PAUSED;
		}

		this.playState = playState;

		this.$container.trigger('slideshowPlayStateChange', [ this.playState ]);
	};

	/**
	 * Returns true if a video is playing, returns false otherwise.
	 *
	 * @return boolean isVideoPlaying
	 */
	self.Slideshow.prototype.isVideoPlaying = function()
	{
		// Loop through video players to check if any is running
		for (var playerID in this.videoPlayers)
		{
			if (!this.videoPlayers.hasOwnProperty(playerID))
			{
				continue;
			}

			// State can be one of the following: Unstarted (-1), ended (0), playing (1), paused (2), buffering (3), video cued (5)
			var state = this.videoPlayers[playerID].state;

			if (state == 1 ||
				state == 3)
			{
				return true;
			}
		}

		return false;
	};

	/**
	 * Pauses all videos
	 */
	self.Slideshow.prototype.pauseAllVideos = function()
	{
		for (var playerID in this.videoPlayers)
		{
			if (!this.videoPlayers.hasOwnProperty(playerID))
			{
				continue;
			}

			var player = this.videoPlayers[playerID].player;

			if (player != null &&
				typeof player.pauseVideo === 'function')
			{
				this.videoPlayers[playerID].state = 2;

				player.pauseVideo();
			}
		}
	};

	/**
	 * Returns whether or not all slides in the passed view have been loaded.
	 *
	 * @param viewID
	 * @returns bool isViewLoaded
	 */
	self.Slideshow.prototype.isViewLoaded = function(viewID)
	{
		var isViewLoaded = true;

		$.each(this.viewData[viewID], $.proxy(function(key, slideData)
		{
			if (slideData.loaded == 0)
			{
				isViewLoaded = false;
			}
		}, this));

		return isViewLoaded;
	};

	/**
	 * Gets the natural size of the passed image jQuery object. The natural size is the original size, as it hasn't been
	 * adapted by any kind of styles on the page.
	 *
	 * This function returns no data. It calls a callback function, as the image may not be fully loaded at the time
	 * this function is called. The callback function will receive the following parameters:
	 *
	 * callback(long naturalWidth, long naturalHeight, mixed data)
	 *
	 * @param $image   (jQuery)
	 * @param callback (function)
	 * @param data     (mixed)
	 */
	self.Slideshow.prototype.getNaturalImageSize = function($image, callback, data)
	{
		if ($image.length <= 0 ||
			!($image instanceof $) ||
			typeof $image.attr('src') !== 'string')
		{
			callback(-1, -1, data);

			return;
		}

		this.onImageLoad($image, $.proxy(function(success, image)
		{
			callback(image.width, image.height, data);
		}, this));
	};

	/**
	 * An IE-safe way to wait for an image to load. The passed callback function will be called once the image has
	 * fully loaded.
	 *
	 * The callback function will be called with the following parameters:
	 *
	 * callback(bool success, HTMLImageElement image, mixed data)
	 *
	 * @param $image   (jQuery)
	 * @param callback (function)
	 * @param data     (mixed)
	 */
	self.Slideshow.prototype.onImageLoad = function($image, callback, data)
	{
		var image = new Image();

		if ($image.length <= 0 ||
			!($image instanceof $) ||
			typeof $image.attr('src') !== 'string')
		{
			callback(false, image, data);

			return;
		}

		image.onload = $.proxy(function()
		{
			callback(true, image, data);
		}, this);

		image.src = $image.attr('src');
	};

	/**
	 * Returns the next view ID, is a random number when random is true.
	 *
	 * @return int viewID
	 */
	self.Slideshow.prototype.getNextViewID = function()
	{
		var viewID = this.currentViewID;

		// Return a random ID when random is true
		if (this.settings['random'])
		{
			var oldViewID = viewID;

			viewID = this.getNextRandomViewID();

			// Only return when it's not the same ID as before
			if (viewID != oldViewID)
			{
				return viewID;
			}
		}

		// If viewID is not a number, return 0
		if (isNaN(parseInt(viewID, 10)))
		{
			return 0;
		}

		// When the end of the views array is reached, return to the first view
		if (viewID >= this.$views.length - 1)
		{
			// When animation should loop, start over, otherwise stay on same view
			if (this.settings['loop'])
			{
				return 0;
			}
			else
			{
				return this.currentViewID;
			}
		}

		// Increment
		return viewID + 1;
	};

	/**
	 * Returns the previous view ID, is a random number when random is true.
	 *
	 * @return int viewID
	 */
	self.Slideshow.prototype.getPreviousViewID = function()
	{
		// Get current view ID
		var viewID = this.currentViewID;

		// If viewID is not a number, set it to 0
		if (isNaN(parseInt(viewID, 10)))
		{
			viewID = 0;
		}

		// Return a random ID when random is true
		if (this.settings['random'])
		{
			var oldViewID = viewID;

			viewID = this.getPreviousRandomViewID();

			// Only return when it's not the same ID as before
			if (viewID != oldViewID)
			{
				return viewID;
			}
		}

		// When the start of the views array is reached, go to the last view
		if (viewID <= 0)
		{
			// When animation should loop, go to the last view, otherwise stay on same view
			if (this.settings['loop'])
			{
				return viewID = this.$views.length - 1;
			}
			else
			{
				return this.currentViewID;
			}
		}

		// Increment
		return viewID -= 1;
	};

	/**
	 * Returns the next random view ID
	 *
	 * @return int nextRandomViewID
	 */
	self.Slideshow.prototype.getNextRandomViewID = function()
	{
		if (!isNaN(parseInt(this.currentViewID, 10)))
		{
			this.randomPreviousHistoryViewIDs.push(this.currentViewID);
		}

		if (this.randomPreviousHistoryViewIDs.length > this.viewIDs.length * 2)
		{
			this.randomPreviousHistoryViewIDs.shift();
		}

		if (this.randomNextHistoryViewIDs.length > 0)
		{
			return this.randomNextHistoryViewIDs.pop();
		}

		// Fill available view IDs array when empty
		if (this.randomAvailableViewIDs === undefined ||
			this.randomAvailableViewIDs.length <= 0)
		{
			this.randomAvailableViewIDs = $.extend(true, [], this.viewIDs);

			this.randomAvailableViewIDs.splice($.inArray(this.currentViewID, this.randomAvailableViewIDs));
		}

		return this.randomAvailableViewIDs.splice(Math.floor(Math.random() * this.randomAvailableViewIDs.length), 1).pop();
	};

	/**
	 * Returns the previous random view ID
	 *
	 * @return int previousRandomViewID
	 */
	self.Slideshow.prototype.getPreviousRandomViewID = function(){

		if (!isNaN(parseInt(this.currentViewID, 10)))
		{
			this.randomNextHistoryViewIDs.push(this.currentViewID);
		}

		if (this.randomNextHistoryViewIDs.length > this.viewIDs.length * 2)
		{
			this.randomNextHistoryViewIDs.shift();
		}

		if (this.randomPreviousHistoryViewIDs.length > 0)
		{
			return this.randomPreviousHistoryViewIDs.pop();
		}

		return this.viewIDs[Math.floor(Math.random() * this.viewIDs.length)];
	};

	/**
	 * Retrieves session ID from the slideshow container
	 *
	 * @return int ID
	 */
	self.Slideshow.prototype.getID = function()
	{
		var ID = this.$container.data('sessionId');

		if (isNaN(parseInt(ID, 10)))
		{
			ID = this.$container.attr('data-session-id');
		}

		return ID;
	};
}());(function()
{
	var $    = jQuery,
		self = slideshow_jquery_image_gallery_script;

	/**
	 * Animate to a certain viewID that's not the same as the current view ID and is within the range of the $views
	 * array.
	 *
	 * The direction of animation can be set by setting the direction to either -1 or 1, depending on whether you'd like
	 * to animate left or right respectively. Direction can be set to 0 or left empty to calculate animation direction
	 * by using the current view ID.
	 *
	 * @param viewID    (int)
	 * @param direction (int)
	 */
	self.Slideshow.prototype.animateTo = function(viewID, direction)
	{
		// Don't animate if a video is playing, or viewID is out of range, or viewID is equal to the current view ID
		if (this.isVideoPlaying() ||
			viewID < 0 ||
			viewID >= this.$views.length ||
			viewID == this.currentViewID)
		{
			return;
		}

		// Disable navigation to prevent user input when animating
		this.navigationActive = false;

		// When direction is 0 or undefined, calculate direction
		if (isNaN(parseInt(direction, 10)) ||
			direction == 0)
		{
			// If viewID is smaller than the current view ID, set direction to -1, otherwise set direction to 1
			if (viewID < this.currentViewID)
			{
				direction = -1;
			}
			else
			{
				direction = 1;
			}
		}

		// Put viewID in viewsInAnimation array so it's registered for recalculation
		this.visibleViews = [this.currentViewID, viewID];

		// Get animation, randomize animation if it's set to random
		var animation  = this.settings['animation'];
		var animations = ['slide', 'slideRight', 'slideUp', 'slideDown', 'fade', 'directFade'];

		if (animation == 'random')
		{
			animation = animations[Math.floor(Math.random() * animations.length)];
		}

		// When going back in slides, slide with the opposite animation
		var animationOpposites = {
			'slide'     : 'slideRight',
			'slideRight': 'slide',
			'slideUp'   : 'slideDown',
			'slideDown' : 'slideUp',
			'fade'      : 'fade',
			'directFade': 'directFade'
		};

		if (direction < 0)
		{
			animation = animationOpposites[animation];
		}

		// Get current and next view
		var $currentView = $(this.$views[this.currentViewID]);
		var $nextView    = $(this.$views[viewID]);

		// Stop any currently running animations
		$currentView.stop(true, true);
		$nextView.stop(true, true);

		// Add current view identifier to next slide
		$nextView.addClass('slideshow_nextView');

		this.recalculateVisibleViews();

		// Set new current view ID
		this.currentViewID = viewID;

		// Fire the slideshowAnimate event
		this.$container.trigger('slideshowAnimate', [ viewID, animation ]);

		// Animate
		switch(animation)
		{
			case 'slide':

				// Prepare next view
				$nextView.css({
					top : 0,
					left: this.$content.width()
				});

				// Animate
				$currentView.animate({ left: -$currentView.outerWidth(true) }, this.settings['slideSpeed'] * 1000);
				$nextView.animate   ({ left: 0                              }, this.settings['slideSpeed'] * 1000);

				// Hide current view out of sight
				setTimeout(
					$.proxy(function()
					{
						$currentView.stop(true, true).css('top', this.$container.outerHeight(true));
					}, this),
					this.settings['slideSpeed'] * 1000
				);

				break;
			case 'slideRight':

				// Prepare next view
				$nextView.css({
					top : 0,
					left: -this.$content.width()
				});

				// Animate
				$currentView.animate({ left: $currentView.outerWidth(true) }, this.settings['slideSpeed'] * 1000);
				$nextView.animate   ({ left: 0                             }, this.settings['slideSpeed'] * 1000);

				// Hide current view
				setTimeout(
					$.proxy(function()
					{
						$currentView.stop(true, true).css('top', this.$container.outerHeight(true));
					}, this),
					this.settings['slideSpeed'] * 1000
				);

				break;
			case 'slideUp':

				// Prepare next view
				$nextView.css({
					top : this.$content.height(),
					left: 0
				});

				// Animate
				$currentView.animate({ top: -$currentView.outerHeight(true) }, this.settings['slideSpeed'] * 1000);
				$nextView.animate   ({ top: 0                               }, this.settings['slideSpeed'] * 1000);

				// Hide current view
				setTimeout(
					$.proxy(function()
					{
						$currentView.stop(true, true).css('top', this.$container.outerHeight(true));
					}, this),
					this.settings['slideSpeed'] * 1000
				);

				break;
			case 'slideDown':

				// Prepare next view
				$nextView.css({
					top : -this.$content.height(),
					left: 0
				});

				// Animate
				$currentView.animate({ top: $currentView.outerHeight(true) }, this.settings['slideSpeed'] * 1000);
				$nextView.animate   ({ top: 0                              }, this.settings['slideSpeed'] * 1000);

				// Hide current view
				setTimeout(
					$.proxy(function()
					{
						$currentView.stop(true, true).css('top', this.$container.outerHeight(true));
					}, this),
					this.settings['slideSpeed'] * 1000
				);

				break;
			case 'fade':

				// Prepare next view
				$nextView.css({
					top    : 0,
					left   : 0,
					display: 'none'
				});

				// Animate
				$currentView.fadeOut((this.settings['slideSpeed'] * 1000) / 2);

				setTimeout(
					$.proxy(function()
					{
						$nextView.fadeIn((this.settings['slideSpeed'] * 1000) / 2);

						$currentView.stop(true, true).css({
							top    : this.$container.outerHeight(true),
							display: 'block'
						});
					}, this),
					(this.settings['slideSpeed'] * 1000) / 2
				);

				break;
			case 'directFade':

				// Prepare next view
				$nextView.css({
					top      : 0,
					left     : 0,
					'z-index': 0,
					display  : 'none'
				});
				$currentView.css({ 'z-index': 1 });

				// Animate
				$nextView.stop(true, true).fadeIn(this.settings['slideSpeed'] * 1000);
				$currentView.stop(true, true).fadeOut(this.settings['slideSpeed'] * 1000);

				setTimeout(
					$.proxy(function()
					{
						$nextView.stop(true, true).css({ 'z-index': 0 });
						$currentView.stop(true, true).css({
							top      : this.$container.outerHeight(true),
							display  : 'block',
							'z-index': 0
						});
					}, this),
					this.settings['slideSpeed'] * 1000
				);

				break;
		}

		// After animation
		setTimeout(
			$.proxy(function()
			{
				// Remove current view identifier class from the previous view
				$currentView.removeClass('slideshow_currentView');
				$nextView.removeClass('slideshow_nextView');
				$nextView.addClass('slideshow_currentView');

				// Update visible views array after animating
				this.visibleViews = [ viewID ];

				// Re-enable navigation
				this.navigationActive = true;

			}, this),
			this.settings['slideSpeed'] * 1000
		);
	};
}());(function()
{
	var $         = jQuery,
		self      = slideshow_jquery_image_gallery_script;

	/**
	 * Set container width to parent width, set overflow width to container width
	 * Only calculates the width when no default width was set.
	 *
	 * If recalculateVisibleViews is set to false, visible views won't be recalculated. If left empty or true, they will.
	 *
	 * @param recalculateViews (boolean, defaults to true)
	 */
	self.Slideshow.prototype.recalculate = function(recalculateViews)
	{
		// Check for slideshow's visibility. If it's invisible, start polling for visibility, then return
		if (!this.$container.is(':visible'))
		{
			// Poll as long as the slideshow is invisible. When visible recalculate and cancel polling
			this.invisibilityTimer = setInterval(
				$.proxy(function()
				{
					if (this.$container.is(':visible'))
					{
						this.recalculate(recalculateViews);

						clearInterval(this.invisibilityTimer);

						this.invisibilityTimer = false;
					}
				}, this),
				500
			);

			return;
		}

		// Walk up the DOM looking for elements with a width the slideshow can use to adjust to
		var $parentElement = this.$parentElement;

		for (var i = 0; $parentElement.width() <= 0; i++)
		{
			$parentElement = $parentElement.parent();

			if (i > 50)
			{
				break;
			}
		}

		// Exit when the slideshow's parent element hasn't changed in width
		if (this.currentWidth == $parentElement.width())
		{
			return;
		}

		// Set current width variable to parent element width to be able to check if any change in width has occurred
		this.currentWidth = $parentElement.width();

		// Calculate slideshow's maximum width (don't include container's margin, as it could be set to 'auto')
		var width = $parentElement.width() - (this.$container.outerWidth() - this.$container.width());

		if (parseInt(this.settings['maxWidth'], 10) > 0 && parseInt(this.settings['maxWidth'], 10) < width)
		{
			width = parseInt(this.settings['maxWidth'], 10);
		}

		// Set width
		this.$container.css('width', Math.floor(width));
		this.$content.css('width', Math.floor(width) - (this.$content.outerWidth(true) - this.$content.width()));

		// Calculate and set the heights
		if (this.settings['preserveSlideshowDimensions'])
		{
			var height = (width * this.settings['dimensionHeight']) / this.settings['dimensionWidth'];

			this.$container.css('height', Math.floor(height));
			this.$content.css('height', Math.floor(height) - (this.$content.outerHeight(true) - this.$content.height()));
		}
		else
		{
			this.$container.css('height', Math.floor(this.settings['height']));
			this.$content.css('height', Math.floor(this.settings['height']));
		}

		// Recalculate hiding position of hidden views
		this.$views.each($.proxy(function(viewID, view)
		{
			if ($.inArray(viewID, this.visibleViews) < 0)
			{
				$(view).css('top', this.$container.outerHeight(true));
			}
		}, this));

		// Fire slideshowResize event
		this.$container.trigger('slideshowResize');

		// Recalculate all views in animation
		if (recalculateViews ||
			typeof recalculateViews !== 'boolean')
		{
			this.recalculateVisibleViews();
		}
	};

	/**
	 * Recalculates all views. Uses recalculateView() to recalculate every separate view.
	 */
	self.Slideshow.prototype.recalculateViews = function()
	{
		$.each(this.$views, $.proxy(function(viewID)
		{
			this.recalculateView(viewID, false);
		}, this));
	};

	/**
	 * Recalculates all slides that are currently defined as being in state of animation. Uses recalculateView() to
	 * recalculate every separate view.
	 */
	self.Slideshow.prototype.recalculateVisibleViews = function()
	{
		// Loop through viewsInAnimation array
		$.each(this.visibleViews, $.proxy(function(key, viewID)
		{
			this.recalculateView(viewID, false);
		}, this));
	};

	/**
	 * Calculates all slides' heights and widths in the passed view, keeping their border widths in mind.
	 *
	 * When forceCalculation is set to true, the view with the passed viewID will be recalculated even though the width
	 * of the view may not have changed.
	 *
	 * TODO Implement separate slide widths. This can be done by making use of the $viewData array using a 'width'
	 * TODO variable.
	 *
	 * @param viewID           (int)
	 * @param forceCalculation (bool) Optional, defaults to false.
	 */
	self.Slideshow.prototype.recalculateView = function(viewID, forceCalculation)
	{
		// Create jQuery object from view
		var $view = $(this.$views[viewID]);

		// Return when the slideshow's width hasn't changed
		if ((typeof forceCalculation !== 'boolean' || !forceCalculation) &&
			this.$content.width() == $view.outerWidth(true))
		{
			return;
		}

		// Find slides in $view
		var $slides = $view.find('.slideshow_slide');

		if ($slides.length <= 0)
		{
			return;
		}

		var viewWidth  = this.$content.width() - ($view.outerWidth(true) - $view.width());
		var viewHeight = this.$content.height() - ($view.outerHeight(true) - $view.height());

		var slideWidth  = Math.floor(viewWidth / $slides.length);
		var slideHeight = viewHeight;
		var spareWidth  = viewWidth % $slides.length;
		var totalWidth  = 0;

		// Cut off left and right margin of outer slides
		$($slides[0]).css('margin-left', 0);
		$($slides[$slides.length - 1]).css('margin-right', 0);

		$.each($slides, $.proxy(function(slideID, slide)
		{
			// Instantiate slide as jQuery object
			var $slide = $(slide);

			// Calculate slide dimensions
			var outerWidth  = $slide.outerWidth(true) - $slide.width();
			var outerHeight = $slide.outerHeight(true) - $slide.height();

			// Add spare width pixels to the last slide
			if (slideID == ($slides.length - 1))
			{
				$slide.width((slideWidth - outerWidth) + spareWidth);
			}
			else
			{
				$slide.width(slideWidth - outerWidth);
			}

			$slide.height(slideHeight - outerHeight);

			// Each slide type has type specific features
			if ($slide.hasClass('slideshow_slide_text'))
			{
				var $anchor = $slide.find('.slideshow_background_anchor');

				if ($anchor.length <= 0)
				{
					return;
				}

				// Calculate image width and height
				var anchorWidth  = $slide.width() - ($anchor.outerWidth(true) - $anchor.width());
				var anchorHeight = $slide.height() - ($anchor.outerHeight(true) - $anchor.height());

				// Set $anchor width and height
				$anchor.css({
					'width' : anchorWidth,
					'height': anchorHeight
				});
			}
			else if ($slide.hasClass('slideshow_slide_image'))
			{
				var $image = $slide.find('img');

				if ($image.length <= 0)
				{
					return;
				}

				var imageAbsoluteOuterWidth  = $image.outerWidth() - $image.width();
				var imageAbsoluteOuterHeight = $image.outerHeight() - $image.height();

				// Calculate image width and height
				var maxImageWidth  = $slide.width() - imageAbsoluteOuterWidth;
				var maxImageHeight = $slide.height() - imageAbsoluteOuterHeight;

				// If stretch images is true, stretch to the slide's sizes.
				if (this.settings['stretchImages'])
				{
					$image.css({
						width : maxImageWidth,
						height: maxImageHeight
					});

					$image.attr({
						width : maxImageWidth,
						height: maxImageHeight
					});
				}
				else // No stretching
				{
					this.getNaturalImageSize($image, $.proxy(function(naturalWidth, naturalHeight)
					{
						var slideDimension,
							imageDimension;

						if (naturalWidth <= 0 ||
							naturalHeight <= 0)
						{
							setTimeout(
								$.proxy(function()
								{
									this.recalculateView(viewID, true);
								}, this),
								500
							);

							return;
						}

						slideDimension = $slide.width() / $slide.height();
						imageDimension = (naturalWidth + imageAbsoluteOuterWidth) / (naturalHeight + imageAbsoluteOuterHeight);

						if (imageDimension >= slideDimension) // Image has a wider dimension than the slide
						{
							// Remove auto centering
							$image.css({
								'margin': '0px',
								'width' : maxImageWidth,
								'height': Math.floor(maxImageWidth / imageDimension)
							});

							// Set width to slide's width, keep height in same dimension
							$image.attr({
								width : maxImageWidth,
								height: Math.floor(maxImageWidth / imageDimension)
							});
						}
						else // Image has a slimmer dimension than the slide
						{
							// Center image
							$image.css({
								'margin-left' : 'auto',
								'margin-right': 'auto',
								'display'     : 'block',
								'width'       : Math.floor(maxImageHeight * imageDimension),
								'height'      : maxImageHeight
							});

							// Set height to slide's height, keep width in same dimension
							$image.attr({
								width : Math.floor(maxImageHeight * imageDimension),
								height: maxImageHeight
							});
						}
					},this));
				}
			}
			else if ($slide.hasClass('slideshow_slide_video'))
			{
				var $videoElement = $slide.find('iframe');

				// If the player already exists, adjust its size. Otherwise, create a new player
				if ($videoElement.length > 0)
				{
					$videoElement.attr({
						width : $slide.width(),
						height: $slide.height()
					});
				}
				else
				{
					var youTubePlayerReadyTimer = setInterval(
						$.proxy(function()
						{
							if (!self.youTubeAPIReady)
							{
								return;
							}

							clearInterval(youTubePlayerReadyTimer);

							// Find element and create a unique element ID for it
							var $element = $slide.find('.slideshow_slide_video_id');

							$element.attr('id', 'slideshow_slide_video_' + Math.floor(Math.random() * 1000000) + '_' + $element.text());

							var showRelatedVideos = $element.attr('data-show-related-videos');

							var player = new YT.Player(
								$element.attr('id'),
								{
									width     : $slide.width(),
									height    : $slide.height(),
									videoId   : $element.text(),
									playerVars:
									{
										wmode: 'opaque',
										rel  : showRelatedVideos
									},
									events    :
									{
										'onReady'      : function(){ },
										'onStateChange': $.proxy(function(event)
										{
											this.videoPlayers[$element.attr('id')].state = event.data;
										}, this)
									}
								}
							);

							var $playerElement = $('#' + $element.attr('id'));

							$playerElement.show();
							$playerElement.attr('src', $playerElement.attr('src') + '&wmode=opaque');

							// Save player element and state referenced by its element ID, to determine whether or not its playing
							this.videoPlayers[$element.attr('id')] = {'player': player, 'state': -1 };
						}, this),
						500
					);
				}
			}

			// Add up total width
			totalWidth += $slide.outerWidth(true);
		}, this));

		$view.css({
			'width' : viewWidth,
			'height': viewHeight
		});
	};
}());(function()
{
	var $    = jQuery,
		self = slideshow_jquery_image_gallery_script;

	/**
	 * Activates description boxes. Only activates when showDescription is set to true.
	 */
	self.Slideshow.prototype.activateDescriptions = function()
	{
		// Only show when showDescription is true
		if (!this.settings['showDescription'])
		{
			return;
		}

		// Loop through descriptions. Show them and if they need to be hidden, hide them
		$.each(this.$slides.find('.slideshow_description'), $.proxy(function(key, description)
		{
			var $description = $(description);

			$description.show();

			if (this.settings['hideDescription'])
			{
				$description.css({
					'position': 'absolute',
					'top'     : this.$container.outerHeight(true)
				});
			}
			else
			{
				$description.css({
					'position': 'absolute',
					'bottom'  : 0
				});
			}
		}, this));

		// Return early when descriptions should not be hidden
		if (!this.settings['hideDescription'])
		{
			return;
		}

		// Adjust description's hiding position on slideshowResize event
		this.$container.bind('slideshowResize', $.proxy(function()
		{
			$.each(this.$container.find('.slideshow_description'), $.proxy(function(key, description)
			{
				$(description).css('top', this.$container.outerHeight(true));
			}, this));
		}, this));

		// Hide descriptions when the slideshow animates
		this.$container.bind('slideshowAnimate', $.proxy(function()
		{
			if (this.visibleViews[1] == undefined)
			{
				return;
			}

			$.each($(this.$views[this.visibleViews[1]]).find('.slideshow_description'), $.proxy(function(key, description)
			{
				$(description).css('top', this.$container.outerHeight(true));
			}, this));
		}, this));

		// Register a mouse enter event to animate showing the description boxes.
		this.$slides.mouseenter($.proxy(function(event)
		{
			var $description = $(event.currentTarget).find('.slideshow_description');

			// Use a timer, so the description doesn't pop up on fly-over
			this.descriptionTimer = setTimeout(
				$.proxy(function()
				{
					// Reset timer to original value
					this.descriptionTimer = '';

					// Animate pop up
					$description
						.stop(true, false)
						.animate({ 'top': (this.$container.outerHeight(true) - $description.outerHeight(true)) }, parseInt(this.settings['descriptionSpeed'] * 1000, 10));
				}, this),
				100
			);
		}, this));

		// Register a mouse leave event to animate hiding the description boxes.
		this.$slides.mouseleave($.proxy(function(event)
		{
			// If a description timer is still set, reset it
			if (this.descriptionTimer === false)
			{
				clearInterval(this.descriptionTimer);

				this.descriptionTimer = false;
			}

			// Find description and stop its current animation, then start animating it out
			$(event.currentTarget)
				.find('.slideshow_description')
				.stop(true, false)
				.animate({ 'top': this.$container.outerHeight(true) }, parseInt(this.settings['descriptionSpeed'] * 1000, 10));
		}, this));
	};

	/**
	 * Activates previous and next buttons, then shows them. Only activates the buttons when controllable is true.
	 */
	self.Slideshow.prototype.activateNavigationButtons = function()
	{
		// Only show buttons if the slideshow is controllable
		if (!this.settings['controllable'])
		{
			return;
		}

		// Register next button click event
		this.$nextButton.click($.proxy(function()
		{
			if (!this.navigationActive)
			{
				return;
			}

			this.pauseAllVideos();

			this.pause(this.PlayStates.TEMPORARILY_PAUSED);
			this.animateTo(this.getNextViewID(), 1);
			this.play();
		}, this));

		// Register previous button click event
		this.$previousButton.click($.proxy(function()
		{
			if (!this.navigationActive)
			{
				return;
			}

			this.pauseAllVideos();

			this.pause(this.PlayStates.TEMPORARILY_PAUSED);
			this.animateTo(this.getPreviousViewID(), -1);
			this.play();
		}, this));

		// If hideNavigationButtons is true, fade them in and out on mouse enter and leave. Simply show them otherwise
		if (this.settings['hideNavigationButtons'])
		{
			this.$container.mouseenter($.proxy(function(){ this.$nextButton.stop(true, true).fadeIn(100); }, this));
			this.$container.mouseleave($.proxy(function(){ this.$nextButton.stop(true, true).fadeOut(500); }, this));

			this.$container.mouseenter($.proxy(function(){ this.$previousButton.stop(true, true).fadeIn(100); }, this));
			this.$container.mouseleave($.proxy(function(){ this.$previousButton.stop(true, true).fadeOut(500); }, this));
		}
		else
		{
			this.$nextButton.show();
			this.$previousButton.show();
		}
	};

	/**
	 * Activates control panel consisting of the play and pause buttons. Only activates the control panel when control
	 * panel is set to true.
	 */
	self.Slideshow.prototype.activateControlPanel = function()
	{
		// Don't activate control panel when it's set to false
		if (!this.settings['controlPanel'])
		{
			return;
		}

		this.$container.bind('slideshowPlayStateChange', $.proxy(function(event, playState)
		{
			if (playState === this.PlayStates.PLAYING)
			{
				this.$togglePlayButton.attr('class', 'slideshow_pause');
			}
			else if (playState === this.PlayStates.PAUSED)
			{
				this.$togglePlayButton.attr('class', 'slideshow_play');
			}
		}, this));

		// Register click event on the togglePlayButton
		this.$togglePlayButton.click($.proxy(function(event)
		{
			if (this.settings['play'])
			{
				this.settings['play'] = false;

				$(event.currentTarget).attr('class', 'slideshow_play');

				this.pause(this.PlayStates.PAUSED);
			}
			else
			{
				this.settings['play'] = true;

				$(event.currentTarget).attr('class', 'slideshow_pause');

				this.play();
			}
		}, this));

		// If hideControlPanel is true, fade it in and out on mouse enter and leave. Simply show it otherwise
		if (this.settings['hideControlPanel'])
		{
			this.$container.mouseenter($.proxy(function(){ this.$controlPanel.stop(true, true).fadeIn(100); }, this));
			this.$container.mouseleave($.proxy(function(){ this.$controlPanel.stop(true, true).fadeOut(500); }, this));
		}
		else
		{
			this.$controlPanel.show();
		}
	};

	/**
	 * Activates the pagination bullets on the slideshow. Only activates the pagination bullets when show pagination
	 * is set to true.
	 */
	self.Slideshow.prototype.activatePagination = function()
	{
		// Only show pagination bullets when showPagination is set to true
		if (!this.settings['showPagination'])
		{
			return;
		}

		// Find ul to add view-bullets to
		this.$pagination.find('.slideshow_pagination_center').html('<ul></ul>');

		var $ul = this.$pagination.find('ul');

		$ul.html('');

		this.$views.each($.proxy(function(viewID)
		{
			// Only add currentView class to currently active view-bullet
			var currentView = '';

			if (viewID == this.currentViewID)
			{
				currentView = 'slideshow_currentView';
			}

			// Add list item
			$ul.append('<li class="slideshow_transparent ' + currentView + '"><span style="display: none;">' + viewID +	'</span></li>');
		}, this));

		// On click of a view-bullet go to the corresponding slide
		this.$pagination.find('li').click($.proxy(function(event)
		{
			if (!this.navigationActive)
			{
				return;
			}

			// Find view ID and check if it's not empty
			var viewID = $(event.currentTarget).find('span').text();

			if (isNaN(parseInt(viewID, 10)))
			{
				return;
			}

			this.pauseAllVideos();

			// Animate to view ID
			this.pause(this.PlayStates.TEMPORARILY_PAUSED);
			this.animateTo(parseInt(viewID, 10), 0);
			this.play();
		}, this));

		// Bind slideshowAnimate to pagination to shift currently active view-bullets
		this.$container.bind(
			'slideshowAnimate',
			$.proxy(function()
			{
				// Get bullets
				var $bullets = this.$pagination.find('li');

				// Remove all currentView classes from the bullets
				$bullets.each($.proxy(function(key, bullet){ $(bullet).removeClass('slideshow_currentView'); }, this));

				// Add the currentView class to the current bullet
				$($bullets[this.currentViewID]).addClass('slideshow_currentView');
			}, this)
		);

		// If hidePagination is true, fade it in and out on mouse enter and leave. Simply show it otherwise
		if (this.settings['hidePagination'])
		{
			this.$container.mouseenter($.proxy(function(){ this.$pagination.stop(true, true).fadeIn(100); }, this));
			this.$container.mouseleave($.proxy(function(){ this.$pagination.stop(true, true).fadeOut(500); }, this));
		}
		else
		{
			this.$pagination.show();
		}
	};

	/**
	 * Activate the pause on hover functionality. Pauses the slideshow on hover over the container, but only when the
	 * mouse remains on there for more than half a second so that it doesn't pause on fly-over.
	 */
	self.Slideshow.prototype.activatePauseOnHover = function()
	{
		// Exit when pauseOnHover is false
		if (!this.settings['pauseOnHover'])
		{
			return;
		}

		// Pause the slideshow when the mouse enters the slideshow container.
		this.$container.mouseenter($.proxy(function()
		{
			clearTimeout(this.pauseOnHoverTimer);

			if (this.playState === this.PlayStates.PAUSED)
			{
				return;
			}

			// Wait 500 milliseconds before pausing the slideshow. If within this time the mouse hasn't left the container, pause.
			this.pauseOnHoverTimer = setTimeout($.proxy(function(){ this.pause(this.PlayStates.TEMPORARILY_PAUSED); }, this), 500);
		}, this));

		// Continue the slideshow when the mouse leaves the slideshow container.
		this.$container.mouseleave($.proxy(function()
		{
			// This will cancel any pausing when the mouse simply flies over, instead of hovering.
			clearTimeout(this.pauseOnHoverTimer);

			if (this.playState === this.PlayStates.PAUSED)
			{
				return;
			}

			// Start slideshow, but only when the interval has been stopped
			if (this.interval === false)
			{
				this.play();
			}
		}, this));
	};
}());